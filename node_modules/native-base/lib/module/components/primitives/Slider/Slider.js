function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

import React from 'react';
import { PanResponder, Platform } from 'react-native';
import { FormControlContext } from '../../composites/FormControl';
import Box from '../Box';
import { useThemeProps } from '../../../hooks';
import { SliderContext } from './Context';

class NBSlider extends React.PureComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "state", {
      barSize: null,
      deltaValue: 0,
      value: this.props.defaultValue || 0
    });

    _defineProperty(this, "panResponder", PanResponder.create({
      onMoveShouldSetPanResponderCapture: () => true,
      onPanResponderMove: (_event, gestureState) => !(this.props.isDisabled || this.props.isReadOnly) && this.onMove(gestureState),
      onPanResponderRelease: () => this.onEndMove(),
      onPanResponderTerminate: () => {}
    }));

    _defineProperty(this, "onBarLayout", event => {
      const {
        width,
        height
      } = event.nativeEvent.layout;
      const barSize = this.props.orientation === 'vertical' ? height : width;
      this.setState({
        barSize
      });
    });

    _defineProperty(this, "capValueWithinRange", (value, range) => {
      if (value < range[0]) return range[0];
      if (value > range[1]) return range[1];
      return value;
    });

    _defineProperty(this, "getValueFromStartOffset", (offset, barSize, rangeMin, rangeMax) => {
      if (barSize === null) return 0;
      return (rangeMax - rangeMin) * offset / barSize;
    });

    _defineProperty(this, "getOffsetFromValue", (value, rangeMin, rangeMax, barSize) => {
      if (barSize === null) return 0;
      const valueOffset = value - rangeMin;
      const totalRange = rangeMax - rangeMin;
      const percentage = valueOffset / totalRange;
      return barSize * percentage;
    });

    _defineProperty(this, "onAccessibilityAction", event => {
      var _this$props$max, _this$props$min, _this$props$accessibi, _this$props$accessibi2;

      const max = (_this$props$max = this.props.max) !== null && _this$props$max !== void 0 ? _this$props$max : 100;
      const min = (_this$props$min = this.props.min) !== null && _this$props$min !== void 0 ? _this$props$min : 0;
      const incrementStep = (_this$props$accessibi = this.props.accessibilityIncrementSteps) !== null && _this$props$accessibi !== void 0 ? _this$props$accessibi : max / 10;
      const decrementStep = (_this$props$accessibi2 = this.props.accessibilityDecrementSteps) !== null && _this$props$accessibi2 !== void 0 ? _this$props$accessibi2 : max / 10;

      switch (event.nativeEvent.actionName) {
        case 'increment':
          this.setState({
            value: Math.min(this.state.value + incrementStep, max)
          });
          break;

        case 'decrement':
          this.setState({
            value: Math.max(this.state.value - decrementStep, min)
          });
          break;

        default:
          break;
      }
    });
  }

  onMove(gestureState) {
    const {
      barSize
    } = this.state;
    const {
      min = 0,
      max = 100
    } = this.props;
    const newDeltaValue = this.getValueFromStartOffset(this.props.orientation === 'vertical' ? -gestureState.dy : gestureState.dx, barSize, this.props.min || 0, this.props.max || 100);
    this.props.onChange && this.props.onChange(this.capValueWithinRange(this.state.value + newDeltaValue, [min, max]));
    this.setState({
      deltaValue: newDeltaValue
    });
  }

  onEndMove() {
    const {
      value,
      deltaValue
    } = this.state;
    const {
      min = 0,
      max = 100
    } = this.props;
    const cappedVal = this.capValueWithinRange(value + deltaValue, [min, max]);
    this.props.onChangeEnd && this.props.onChangeEnd(cappedVal);
    this.setState({
      value: cappedVal,
      deltaValue: 0
    });
  }

  render() {
    var _this$props$min2, _this$props$max2, _this$props$accessibi3;

    const {
      value,
      deltaValue,
      barSize
    } = this.state;
    const min = (_this$props$min2 = this.props.min) !== null && _this$props$min2 !== void 0 ? _this$props$min2 : 0;
    const max = (_this$props$max2 = this.props.max) !== null && _this$props$max2 !== void 0 ? _this$props$max2 : 100;
    const cappedValue = this.capValueWithinRange(value + deltaValue, [min, max]);
    const sliderOffset = this.getOffsetFromValue(cappedValue, min, max, barSize);
    return /*#__PURE__*/React.createElement(SliderContext.Provider, {
      value: {
        sliderOffset,
        trackColor: this.props.trackColor,
        colorScheme: this.props.activeColor,
        barSize: this.state.barSize,
        panResponder: this.panResponder,
        isReversed: this.props.isReversed,
        thumbSize: this.props.thumbSize,
        sliderSize: this.props.sliderSize,
        orientation: this.props.orientation,
        isDisabled: this.props.isDisabled,
        value: this.state.value
      }
    }, /*#__PURE__*/React.createElement(Box, _extends({
      position: "relative",
      display: "flex",
      my: 3,
      justifyContent: "center",
      alignItems: "center",
      minHeight: 3,
      minWidth: "100%"
    }, this.props, {
      onLayout: this.onBarLayout,
      opacity: this.props.isDisabled ? 0.4 : 1
    }, Platform.OS === 'web' && this.props.isDisabled ? {
      disabled: this.props.isDisabled,
      cursor: this.props.isDisabled ? 'not-allowed' : 'auto'
    } : {}, {
      //A11y props
      accessible: true,
      accessibilityRole: "adjustable",
      accessibilityLabel: (_this$props$accessibi3 = this.props.accessibilityLabel) !== null && _this$props$accessibi3 !== void 0 ? _this$props$accessibi3 : 'Slider',
      accessibilityValue: {
        min,
        max,
        now: value
      },
      accessibilityHint: this.props.accessibilityHint,
      accessibilityActions: [{
        name: 'increment',
        label: 'Increment'
      }, {
        name: 'decrement',
        label: 'Decrement'
      }],
      onAccessibilityAction: this.onAccessibilityAction
    }), this.state.barSize && this.props.children));
  }

}

_defineProperty(NBSlider, "contextType", SliderContext);

const Slider = ({ ...props
}) => {
  const formControlContext = React.useContext(FormControlContext);
  const newProps = useThemeProps('Slider', { ...formControlContext,
    ...props
  });
  return /*#__PURE__*/React.createElement(NBSlider, newProps);
};

export default /*#__PURE__*/React.memo(Slider);
//# sourceMappingURL=Slider.js.map