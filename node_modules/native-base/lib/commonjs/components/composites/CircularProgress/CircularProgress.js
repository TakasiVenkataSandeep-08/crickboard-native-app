"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _get = _interopRequireDefault(require("lodash/get"));

var _react = _interopRequireDefault(require("react"));

var _reactNative = require("react-native");

var _native = _interopRequireDefault(require("styled-components/native"));

var _styledSystem = require("styled-system");

var _hooks = require("../../../hooks");

var _utils = require("../../../utils");

var _Box = _interopRequireDefault(require("../../primitives/Box"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

const StyleAnimatedView = (0, _native.default)(_reactNative.Animated.View)(_styledSystem.color, _styledSystem.border);

const CircularProgress = ({
  value,
  size,
  isIndeterminate,
  thickness,
  color: colorProp,
  trackColor,
  max,
  min,
  ...props
}, ref) => {
  const theme = (0, _hooks.useTheme)();
  const isDomUsable = (0, _utils.canUseDom)();

  if (min) {
    value = value - min;
  }

  if (!size) {
    size = 'lg';
  }

  let sizeProps;
  let newProps = (0, _hooks.useThemeProps)('CircularProgress', {
    size: size
  });

  if (typeof size === 'string') {
    sizeProps = {
      height: newProps.height,
      width: newProps.width
    };
  } else {
    sizeProps = {
      height: size,
      width: size
    };
  } // fetching size from theme for passing into style prop


  const themeHeight = (0, _get.default)(theme, 'space.' + sizeProps.height);
  const themeWidth = (0, _get.default)(theme, 'space.' + sizeProps.width);
  const styleSize = {
    height: themeHeight ? parseInt(themeHeight.slice(themeHeight.Length, -2), 10) : sizeProps.height,
    width: themeWidth ? parseInt(themeWidth.slice(themeWidth.Length, -2), 10) : sizeProps.width
  };
  let defaultThickness = 8;

  if (thickness) {
    defaultThickness = thickness;
  }

  const degree = new _reactNative.Animated.Value(0);

  if (isIndeterminate) {
    if (isDomUsable) {
      _reactNative.Animated.loop(_reactNative.Animated.timing(degree, {
        toValue: 1,
        duration: 600,
        easing: _reactNative.Easing.linear,
        useNativeDriver: false
      })).start();
    }
  }

  const [viewHeight, setViewHeight] = _react.default.useState(0);

  const layout = e => {
    let height = e.nativeEvent.layout.height;
    setViewHeight(height);
  };

  const defaultStyling = {
    borderBottomLeftRadius: viewHeight / 2,
    borderBottomRightRadius: viewHeight / 2,
    borderTopLeftRadius: viewHeight / 2,
    borderTopRightRadius: viewHeight / 2,
    borderLeftWidth: defaultThickness,
    borderBottomWidth: defaultThickness,
    position: 'absolute',
    borderLeftColor: 'transparent',
    borderBottomColor: 'transparent',
    ...styleSize
  };

  const styles = _reactNative.StyleSheet.create({
    firstProgressLayer: {
      borderTopWidth: defaultThickness,
      borderRightWidth: defaultThickness,
      ...defaultStyling,
      transform: [{
        rotateZ: '-135deg'
      }]
    },
    secondProgressLayer: {
      borderTopWidth: defaultThickness,
      borderRightWidth: defaultThickness,
      ...defaultStyling,
      transform: [{
        rotateZ: '45deg'
      }]
    },
    offsetLayer: {
      borderTopWidth: defaultThickness,
      borderRightWidth: defaultThickness,
      ...defaultStyling,
      borderRadius: viewHeight / 2,
      transform: [{
        rotateZ: '-135deg'
      }]
    },
    animateStyle: {
      borderTopWidth: defaultThickness,
      borderRightWidth: defaultThickness,
      ...defaultStyling,
      transform: [{
        rotateZ: degree.interpolate({
          inputRange: [0, 1],
          outputRange: ['0deg', '360deg']
        })
      }]
    }
  });

  let halfSide = (max ? min ? max - min : max : 100) / 2; // calculating the halfvalue of the progress according to min and max

  const propStyle = (percent, base_degrees) => {
    const rotateBy = base_degrees + percent * 180 / halfSide;
    return {
      transform: [{
        rotateZ: rotateBy + 'deg'
      }]
    };
  };

  const renderThirdLayer = percent => {
    if (percent > halfSide) {
      return /*#__PURE__*/_react.default.createElement(_Box.default, {
        borderTopColor: colorProp ? colorProp : 'blue.700',
        borderRightColor: colorProp ? colorProp : 'blue.700',
        style: [styles.secondProgressLayer, propStyle(percent - halfSide, 45)]
      });
    } else {
      return /*#__PURE__*/_react.default.createElement(_Box.default, {
        borderTopColor: trackColor ? trackColor : 'blueGray.200',
        borderRightColor: trackColor ? trackColor : 'blueGray.200',
        style: styles.offsetLayer
      });
    }
  };

  let firstProgressLayerStyle;

  if (value > halfSide) {
    firstProgressLayerStyle = propStyle(halfSide, -135);
  } else {
    firstProgressLayerStyle = propStyle(value, -135);
  }

  return /*#__PURE__*/_react.default.createElement(_Box.default, _extends({}, sizeProps, {
    rounded: viewHeight / 2,
    borderWidth: defaultThickness,
    borderColor: trackColor ? trackColor : 'blueGray.200',
    justifyContent: "center",
    alignItems: "center"
  }, props, {
    ref: ref
  }), !isIndeterminate ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_Box.default, {
    onLayout: layout,
    borderTopColor: colorProp ? colorProp : 'blue.700',
    borderRightColor: colorProp ? colorProp : 'blue.700',
    style: [styles.firstProgressLayer, firstProgressLayerStyle]
  }), renderThirdLayer(value), /*#__PURE__*/_react.default.createElement(_Box.default, {
    fontSize: sizeProps.height / 4
  }, props.children)) : /*#__PURE__*/_react.default.createElement(StyleAnimatedView, {
    onLayout: layout,
    borderTopColor: colorProp ? colorProp : 'blue.700',
    borderRightColor: colorProp ? colorProp : 'blue.700',
    style: styles.animateStyle
  }));
};

var _default = /*#__PURE__*/_react.default.memo( /*#__PURE__*/_react.default.forwardRef(CircularProgress));

exports.default = _default;
//# sourceMappingURL=CircularProgress.js.map