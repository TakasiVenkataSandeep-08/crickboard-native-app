"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateProps = calculateProps;

var _get = _interopRequireDefault(require("lodash/get"));

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _mergeWith = _interopRequireDefault(require("lodash/mergeWith"));

var _cloneDeep = _interopRequireDefault(require("lodash/cloneDeep"));

var _base = require("./../../theme/base");

var _tools = require("./../../theme/tools");

var _hooks = require("./../../theme/hooks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
 Extract props from theme props and omit those from props
*/
function extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint) {
  let newProps = {};

  for (let property in props) {
    // If the property exists in theme map then get its value
    if (_base.themePropertyMap[property]) {
      let propValues = extractPropertyFromFunction(property, props, theme, componentTheme);

      if (typeof propValues === 'string' || typeof propValues === 'number') {
        newProps[property] = propValues;
      } else if (!(0, _isNil.default)(propValues)) {
        for (let nestedProp in propValues) {
          newProps[nestedProp] = (0, _get.default)(theme, "".concat(_base.themePropertyMap[nestedProp], ".").concat(propValues[nestedProp]), propValues[nestedProp]);
        }
      } else if (property === 'shadow') {
        let shadowProps = theme[_base.themePropertyMap[property]](colorModeProps)[props[property]];

        if (!(0, _isNil.default)(shadowProps)) {
          newProps = { ...newProps,
            ...shadowProps
          };
        }
      } else {
        newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);
      }
    } else {
      newProps[property] = resolveValueWithBreakpoint(props[property], currentBreakpoint, property);
    }
  }

  return (0, _cloneDeep.default)(newProps);
}
/*
Remove props from defaultProps that are already present in props
*/


function filterDefaultProps(props, defaultProps) {
  let [, resultProps] = (0, _tools.extractInObject)(defaultProps, Object.keys(props));
  return resultProps;
}
/*
If property is functional in componentTheme, get its returned object
*/


const extractPropertyFromFunction = (property, props, theme, componentTheme) => {
  let propValues;

  if (componentTheme && typeof componentTheme[_base.themePropertyMap[property]] === 'function') {
    let funcProps = componentTheme[_base.themePropertyMap[property]]({
      theme,
      ...props
    }); // Check if returned object from componentTheme is a nested object


    let isNested = Object.keys(funcProps).some(function (key) {
      return funcProps[key] && typeof funcProps[key] === 'object';
    });
    propValues = isNested ? { ...(0, _get.default)(funcProps, "".concat(props[property]))
    } : { ...funcProps
    };
  } else {
    propValues = (0, _get.default)(componentTheme, "".concat(_base.themePropertyMap[property], ".").concat(props[property]));
  }

  return propValues;
};
/*
Merge _props and apply contrastText color if not passed by theme or user
*/


function mergeUnderscoreProps(newProps, props) {
  const _props = Object.keys(newProps).filter(propName => propName.startsWith('_'));

  _props.forEach(propName => {
    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;

    // Adding color based on bg contrast if no color is given
    const bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;
    const textColor = bg ? {
      color: (0, _hooks.useContrastText)(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)
    } : {}; // Overriding calculated props with user added props

    newProps[propName] = { ...textColor,
      ...newProps[propName],
      ...props[propName]
    };
  });

  return newProps;
}
/*
Checks the property and resolves it if it has breakpoints
*/


const resolveValueWithBreakpoint = (values, currentBreakpoint, property) => {
  if ((0, _tools.hasValidBreakpointFormat)(values, property)) {
    return (0, _tools.findLastValidBreakpoint)(values, currentBreakpoint);
  } else {
    return values;
  }
};

function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {
  let currentBreakpoint = (0, _tools.getClosestBreakpoint)(theme.breakpoints, windowWidth);

  if (!props) {
    props = {};
  }

  let newProps;

  if (componentTheme) {
    // Extracting props from defaultProps
    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style

    let componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle({
      theme,
      ...newProps,
      ...props,
      ...colorModeProps
    });
    newProps = (0, _mergeWith.default)(newProps, componentBaseStyle, // @ts-ignore
    (objValue, srcValue, key) => {
      if (!(0, _isNil.default)(objValue)) {
        delete newProps[key];
      }
    });
    const variant = props.variant || (0, _get.default)(componentTheme, 'defaultProps.variant'); // Extracting props from variant

    if (variant && componentTheme.variants && componentTheme.variants[variant]) {
      const colorScheme = props.colorScheme || (0, _get.default)(componentTheme, 'defaultProps.colorScheme');
      let variantProps = componentTheme.variants[variant]({ ...props,
        ...newProps,
        colorScheme,
        theme,
        ...colorModeProps
      }); // added this to handle order of props

      newProps = (0, _mergeWith.default)(newProps, variantProps, // @ts-ignore
      (objValue, srcValue, key) => {
        if (!(0, _isNil.default)(objValue)) {
          delete newProps[key];
        }
      });
      delete newProps.variant;
      delete newProps.colorScheme;
    }
  } // Extracting props from normal props


  let extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props
  // @ts-ignore

  newProps = (0, _mergeWith.default)(newProps, extractedProps, (objValue, srcValue, key) => {
    if (!(0, _isNil.default)(objValue)) {
      delete newProps[key];
    }
  });
  newProps = mergeUnderscoreProps(newProps, props);
  return newProps;
}
//# sourceMappingURL=utils.js.map